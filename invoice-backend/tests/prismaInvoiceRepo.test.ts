import "reflect-metadata";
import { describe, expect, test, vi } from "vitest";
import prisma from "../libs/__mocks__/prisma";
import { PrismaInvoiceRepository } from "../src/repositories/implementations/prismaInvoiceRepository";
import { DatabaseConnectionMock } from "./database.connection.mock";
import { IDatabaseConnection } from "../src/database/database.connection";
import { Invoice } from "@prisma/client";
import {
  Decimal,
  PrismaClientKnownRequestError,
} from "@prisma/client/runtime/library";

vi.mock("../libs/prisma");

const mockInvoiceParams = {
  id: "D64FUO",
  createdAt: "2021-08-21",
  paymentDue: "2021-09-20",
  description: "Graphic Design",
  paymentTerms: 30,
  clientName: "Alex Grim",
  clientEmail: "alexgrim@mail.com",
  status: "pending",
  senderAddress: {
    street: "19 Union Terrace",
    city: "London",
    postCode: "E1 3EZ",
    country: "United Kingdom",
  },
  clientAddress: {
    street: "84 Church Way",
    city: "Bradford",
    postCode: "BD1 9PB",
    country: "United Kingdom",
  },
  items: [
    {
      id: "gjhgjhgjhg",
      name: "Banner Design",
      quantity: 1,
      price: 156,
      total: 156,
    },
    {
      name: "Email Design",
      quantity: 2,
      price: 200,
      total: 400,
      id: "hgfdyrdyi456t",
    },
  ],
  total: 556.0,
};

const mockInvoicePrismaResponse = {
  id: "D64FUO",
  createdAt: "2021-08-21",
  paymentDue: "2021-09-20",
  description: "Graphic Design",
  paymentTerms: 30,
  clientName: "Alex Grim",
  clientEmail: "alexgrim@mail.com",
  status: "pending",
  senderAddress: {
    street: "19 Union Terrace",
    city: "London",
    postCode: "E1 3EZ",
    country: "United Kingdom",
  },
  clientAddress: {
    street: "84 Church Way",
    city: "Bradford",
    postCode: "BD1 9PB",
    country: "United Kingdom",
  },
  items: [
    {
      name: "Banner Design",
      quantity: 1,
      price: 156,
      total: 156,
    },
    {
      name: "Email Design",
      quantity: 2,
      price: 200,
      total: 400,
    },
  ],
  total: 100.5,
};

const mockResponseWithIds = {
  ...mockInvoicePrismaResponse,
  clientAddressId: 1,
  senderAddressId: 4,
  total: new Decimal(mockInvoicePrismaResponse.total),
};

const mockRepo = new PrismaInvoiceRepository(
  new DatabaseConnectionMock() as IDatabaseConnection,
);

describe("Prisma Query: createInvoice", () => {
  test("should return invoice object with matching properties", async () => {
    prisma.invoice.create.mockResolvedValue(
      mockInvoicePrismaResponse as unknown as Invoice,
    );

    const createdInvoice = await mockRepo.create(mockInvoiceParams);

    expect(createdInvoice).toStrictEqual(mockInvoicePrismaResponse);
  });

  test("should throw error when invoice ID already exists", async () => {
    // Mock the implementation to throw a unique ID error
    prisma.invoice.create.mockRejectedValue(
      new PrismaClientKnownRequestError(
        "Unique constraint failed on the fields: (`id`)",
        {
          code: "P2002",
          clientVersion: "4.7.1",
        },
      ),
    );

    // Expect the create method to reject with the correct error
    await expect(mockRepo.create(mockInvoiceParams)).rejects.toThrow();
    await expect(mockRepo.create(mockInvoiceParams)).rejects.toThrowError(
      /Unique constraint failed on the fields: \(`id`\)/,
    );
  });

  test("should throw error: Failed to create invoice", async () => {
    // Mock the implementation to throw a specific error once
    prisma.invoice.create.mockImplementation(() => {
      throw new Error("Failed to create invoice");
    });

    // Expect the create method to reject with the correct error
    await expect(mockRepo.create(mockInvoiceParams)).rejects.toThrowError(
      "Failed to create invoice",
    );
  });

  // Cannot figure our proper types for this with Prisma's autogenerated types
  test("should create an invoice with missing optional fields", async () => {
    // Create incomplete invoice params by omitting `clientEmail`
    const incompleteInvoiceParams: Invoice | Partial<Invoice> = {
      ...mockInvoiceParams,
      // total: new Decimal(mockInvoicePrismaResponse.total),
      clientEmail: undefined,
    };

    // The expected response should match the default value set by the `create` method
    const expectedResponse: Invoice | Partial<Invoice> = {
      ...mockInvoicePrismaResponse,
      // total: new Decimal(mockInvoicePrismaResponse.total),
      clientEmail: "", // `create` method sets it to an empty string if undefined
    };

    // Mock the `prisma.invoice.create` method to return the expected response
    prisma.invoice.create.mockResolvedValue(
      expectedResponse as unknown as Invoice,
    );

    // Call the `create` method of the repository
    const createdInvoice = await mockRepo.create(incompleteInvoiceParams);

    // Validate that the `clientEmail` was set to an empty string
    expect((createdInvoice as Invoice).clientEmail).toBe("");
    // Ensure the entire object matches the expected response
    expect(createdInvoice).toStrictEqual(expectedResponse);
  });
});

describe("Prisma Query: findAll", () => {
  test("should return an array of invoices", async () => {
    const mockInvoices: Invoice[] = [
      {
        ...mockResponseWithIds,
        id: "D64FUO",
      },
      {
        ...mockResponseWithIds,
        id: "D64FUP",
      },
    ];

    prisma.invoice.findMany.mockResolvedValue(mockInvoices);

    const invoices = await mockRepo.findAll();

    expect(invoices).toStrictEqual(mockInvoices);
  });

  test("should return an empty array if no invoices are found", async () => {
    prisma.invoice.findMany.mockResolvedValue([]);

    const invoices = await mockRepo.findAll();

    expect(invoices).toStrictEqual([]);
  });

  test("should throw an error if an error occurs", async () => {
    prisma.invoice.findMany.mockRejectedValue(new Error("Database error"));

    await expect(mockRepo.findAll()).rejects.toThrowError("Database error");
  });
});

describe("Prisma Query: findById", () => {
  test("should return an invoice object if found", async () => {
    const mockInvoice: Invoice = {
      ...mockResponseWithIds,
      id: "D64FUO",
    };

    prisma.invoice.findUniqueOrThrow.mockResolvedValue(mockInvoice);

    const invoice = await mockRepo.findById("D64FUO");

    expect(invoice).toStrictEqual(mockInvoice);
  });

  test("should throw error if no invoice is found", async () => {
    prisma.invoice.findUniqueOrThrow.mockRejectedValue(
      new PrismaClientKnownRequestError("Invoice not found", {
        code: "P2025",
        clientVersion: "5.19.0",
      }),
    );

    await expect(mockRepo.findById("FG86SE")).rejects.toThrowError(
      /Invoice not found/,
    );
  });

  test("should throw an error if an error occurs", async () => {
    prisma.invoice.findUniqueOrThrow.mockRejectedValue(
      new Error("Database error"),
    );

    await expect(mockRepo.findById("D64FUO")).rejects.toThrowError(
      "Database error",
    );
  });
});

describe("Prisma Query: updateInvoice", () => {
  test("should return the updated invoice object", async () => {
    const mockInvoice: Invoice = {
      ...mockResponseWithIds,
      id: "D64FUO",
      total: new Decimal(mockInvoicePrismaResponse.total),
    };

    prisma.$transaction.mockImplementation(async (callback) => {
      await callback(prisma);
      return mockInvoice;
    });

    prisma.item.deleteMany.mockResolvedValue({ count: 1 });
    prisma.invoice.update.mockResolvedValue(mockInvoice);
    prisma.invoice.findUnique.mockResolvedValue(mockInvoice);

    const updatedInvoice = await mockRepo.update("D64FUO", mockInvoice);

    expect(updatedInvoice).toStrictEqual(mockInvoice);
    expect(prisma.$transaction).toHaveBeenCalled();
    expect(prisma.item.deleteMany).toHaveBeenCalledWith({
      where: { invoiceId: "D64FUO" },
    });
    expect(prisma.invoice.update).toHaveBeenCalled();
  });

  test("should throw error if no invoice is found", async () => {
    prisma.$transaction.mockRejectedValue(
      new PrismaClientKnownRequestError("Invoice not found", {
        code: "P2025",
        clientVersion: "4.7.1",
      }),
    );

    await expect(
      mockRepo.update("D64F3E", mockInvoicePrismaResponse),
    ).rejects.toThrowError(/Invoice not found/);
  });

  test("should throw an error if an error occurs", async () => {
    prisma.$transaction.mockRejectedValue(new Error("Database error"));

    await expect(
      mockRepo.update("D64FDS", mockInvoicePrismaResponse),
    ).rejects.toThrowError("Database error");
  });
});

describe("Prisma Query: deleteInvoice", () => {
  test("should return the deleted invoice object", async () => {
    const mockInvoice: Invoice = {
      ...mockResponseWithIds,
      id: "D64FUO",
      total: new Decimal(mockInvoicePrismaResponse.total),
    };

    prisma.invoice.delete.mockResolvedValue(mockInvoice);

    const deletedInvoice = await mockRepo.delete("D64FUO");

    expect(deletedInvoice).toStrictEqual(mockInvoice);
  });

  test("should throw error if no invoice is found", async () => {
    prisma.invoice.delete.mockRejectedValue(
      new PrismaClientKnownRequestError("Invoice not found", {
        code: "P2025",
        clientVersion: "4.7.1",
      }),
    );

    await expect(mockRepo.delete("D64F3E")).rejects.toThrowError(
      /Invoice not found/,
    );
  });

  test("should throw an error if an error occurs", async () => {
    prisma.invoice.delete.mockRejectedValue(new Error("Database error"));

    await expect(mockRepo.delete("D64FDS")).rejects.toThrowError(
      "Database error",
    );
  });
});

describe("Prisma Query: markAsPaid", () => {
  test("should return the updated invoice object", async () => {
    const mockInvoice: Invoice = {
      ...mockResponseWithIds,
      id: "D64FUO",
      total: new Decimal(mockInvoicePrismaResponse.total),
      status: "paid",
    };

    prisma.invoice.update.mockResolvedValue(mockInvoice);

    const updatedInvoice = await mockRepo.markAsPaid("D64FUO");
    const expected = { ...mockInvoice };
    expect(updatedInvoice).toStrictEqual(expected);
  });

  test("should throw error if no invoice is found", async () => {
    prisma.invoice.update.mockRejectedValue(
      new PrismaClientKnownRequestError("Invoice not found", {
        code: "P2025",
        clientVersion: "4.7.1",
      }),
    );

    await expect(mockRepo.markAsPaid("D64F3E")).rejects.toThrowError(
      /Invoice not found/,
    );
  });

  test("should throw an error if an error occurs", async () => {
    prisma.invoice.update.mockRejectedValue(new Error("Database error"));

    await expect(mockRepo.markAsPaid("D64FDS")).rejects.toThrowError(
      "Database error",
    );
  });
});
