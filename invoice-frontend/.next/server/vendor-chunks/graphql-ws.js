"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphql-ws";
exports.ids = ["vendor-chunks/graphql-ws"];
exports.modules = {

/***/ "(ssr)/./node_modules/graphql-ws/lib/client.mjs":
/*!************************************************!*\
  !*** ./node_modules/graphql-ws/lib/client.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.isMessage),\n/* harmony export */   parseMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage),\n/* harmony export */   stringifyMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage),\n/* harmony export */   validateMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.validateMessage)\n/* harmony export */ });\n/* harmony import */ var _common_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.mjs */ \"(ssr)/./node_modules/graphql-ws/lib/common.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/graphql-ws/lib/utils.mjs\");\n/**\n *\n * client\n *\n */ var __await = undefined && undefined.__await || function(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n};\nvar __asyncGenerator = undefined && undefined.__asyncGenerator || function(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n};\n\n\n/** This file is the entry point for browsers, re-export common elements. */ \n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */ function createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for(let i = 0; i < retries; i++){\n            retryDelay *= 2;\n        }\n        await new Promise((resolve)=>setTimeout(resolve, retryDelay + // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */ generateID = function generateUUID() {\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n            const r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 0x3 | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error(\"Invalid WebSocket implementation provided\");\n        }\n        ws = webSocketImpl;\n    } else if (typeof WebSocket !== \"undefined\") {\n        ws = WebSocket;\n    } else if (typeof global !== \"undefined\") {\n        ws = global.WebSocket || // @ts-expect-error: Support more browsers\n        global.MozWebSocket;\n    } else if (false) {}\n    if (!ws) throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (()=>{\n        const message = (()=>{\n            const listeners = {};\n            return {\n                on (id, listener) {\n                    listeners[id] = listener;\n                    return ()=>{\n                        delete listeners[id];\n                    };\n                },\n                emit (message) {\n                    var _a;\n                    if (\"id\" in message) (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                }\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [\n                on.connecting\n            ] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [\n                on.opened\n            ] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [\n                on.connected\n            ] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [\n                on.ping\n            ] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [\n                on.pong\n            ] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [\n                message.emit,\n                on.message\n            ] : [\n                message.emit\n            ],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [\n                on.closed\n            ] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [\n                on.error\n            ] : []\n        };\n        return {\n            onMessage: message.on,\n            on (event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return ()=>{\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit (event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [\n                    ...listeners[event]\n                ]){\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            }\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on(\"error\", (err)=>{\n                listening.forEach((unlisten)=>unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on(\"closed\", (event)=>{\n                listening.forEach((unlisten)=>unlisten());\n                cb(event);\n            })\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise((connected, denied)=>(async ()=>{\n                if (retrying) {\n                    await retryWait(retries);\n                    // subscriptions might complete while waiting for retry\n                    if (!locks) {\n                        connecting = undefined;\n                        return denied({\n                            code: 1000,\n                            reason: \"All Subscriptions Gone\"\n                        });\n                    }\n                    retries++;\n                }\n                emitter.emit(\"connecting\");\n                const socket = new WebSocketImpl(typeof url === \"function\" ? await url() : url, _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL);\n                let connectionAckTimeout, queuedPing;\n                function enqueuePing() {\n                    if (isFinite(keepAlive) && keepAlive > 0) {\n                        clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                        queuedPing = setTimeout(()=>{\n                            if (socket.readyState === WebSocketImpl.OPEN) {\n                                socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Ping\n                                }));\n                                emitter.emit(\"ping\", false, undefined);\n                            }\n                        }, keepAlive);\n                    }\n                }\n                errorOrClosed((errOrEvent)=>{\n                    connecting = undefined;\n                    clearTimeout(connectionAckTimeout);\n                    clearTimeout(queuedPing);\n                    denied(errOrEvent);\n                    if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n                        socket.close(4499, \"Terminated\"); // close event is artificial and emitted manually, see `Client.terminate()` below\n                        socket.onerror = null;\n                        socket.onclose = null;\n                    }\n                });\n                socket.onerror = (err)=>emitter.emit(\"error\", err);\n                socket.onclose = (event)=>emitter.emit(\"closed\", event);\n                socket.onopen = async ()=>{\n                    try {\n                        emitter.emit(\"opened\", socket);\n                        const payload = typeof connectionParams === \"function\" ? await connectionParams() : connectionParams;\n                        // connectionParams might take too long causing the server to kick off the client\n                        // the necessary error/close event is already reported - simply stop execution\n                        if (socket.readyState !== WebSocketImpl.OPEN) return;\n                        socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(payload ? {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit,\n                            payload\n                        } : {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit\n                        }, replacer));\n                        if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n                            connectionAckTimeout = setTimeout(()=>{\n                                socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.ConnectionAcknowledgementTimeout, \"Connection acknowledgement timeout\");\n                            }, connectionAckWaitTimeout);\n                        }\n                        enqueuePing(); // enqueue ping (noop if disabled)\n                    } catch (err) {\n                        emitter.emit(\"error\", err);\n                        socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, \"Internal client error\"));\n                    }\n                };\n                let acknowledged = false;\n                socket.onmessage = ({ data })=>{\n                    try {\n                        const message = (0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage)(data, reviver);\n                        emitter.emit(\"message\", message);\n                        if (message.type === \"ping\" || message.type === \"pong\") {\n                            emitter.emit(message.type, true, message.payload); // received\n                            if (message.type === \"pong\") {\n                                enqueuePing(); // enqueue next ping (noop if disabled)\n                            } else if (!disablePong) {\n                                // respond with pong on ping\n                                socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(message.payload ? {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong,\n                                    payload: message.payload\n                                } : {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong\n                                }));\n                                emitter.emit(\"pong\", false, message.payload);\n                            }\n                            return; // ping and pongs can be received whenever\n                        }\n                        if (acknowledged) return; // already connected and acknowledged\n                        if (message.type !== _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionAck) throw new Error(`First message cannot be of type ${message.type}`);\n                        clearTimeout(connectionAckTimeout);\n                        acknowledged = true;\n                        emitter.emit(\"connected\", socket, message.payload); // connected = socket opened + acknowledged\n                        retrying = false; // future lazy connects are not retries\n                        retries = 0; // reset the retries on connect\n                        connected([\n                            socket,\n                            new Promise((_, reject)=>errorOrClosed(reject))\n                        ]);\n                    } catch (err) {\n                        socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                        emitter.emit(\"error\", err);\n                        socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, \"Bad response\"));\n                    }\n                };\n            })()));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;\n        let release = ()=>{\n        // releases this connection\n        };\n        const released = new Promise((resolve)=>release = resolve);\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(()=>{\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = ()=>socket.close(1000, \"Normal Closure\");\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(()=>{\n                                if (socket.readyState === WebSocketImpl.OPEN) complete();\n                            }, lazyCloseTimeoutMs);\n                        } else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose\n            ])\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */ function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalServerError,\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError,\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadRequest,\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse,\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.Unauthorized,\n            // CloseCode.Forbidden, might grant access out after retry\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubprotocolNotAcceptable,\n            // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n            // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubscriberAlreadyExists,\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.TooManyInitialisationRequests\n        ].includes(errOrCloseEvent.code))) throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed) return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000) return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent)) throw errOrCloseEvent;\n        // looks good, start retrying\n        return retrying = true;\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async ()=>{\n            locks++;\n            for(;;){\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                } catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n                    } catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    function subscribe(payload, sink) {\n        const id = generateID(payload);\n        let done = false, errored = false, releaser = ()=>{\n            // for handling completions before connect\n            locks--;\n            done = true;\n        };\n        (async ()=>{\n            locks++;\n            for(;;){\n                try {\n                    const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                    // if done while waiting for connect, release the connection lock right away\n                    if (done) return release();\n                    const unlisten = emitter.onMessage(id, (message)=>{\n                        switch(message.type){\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Next:\n                                {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                                    sink.next(message.payload);\n                                    return;\n                                }\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Error:\n                                {\n                                    errored = true, done = true;\n                                    sink.error(message.payload);\n                                    releaser();\n                                    return;\n                                }\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete:\n                                {\n                                    done = true;\n                                    releaser(); // release completes the sink\n                                    return;\n                                }\n                        }\n                    });\n                    socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                        id,\n                        type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Subscribe,\n                        payload\n                    }, replacer));\n                    releaser = ()=>{\n                        if (!done && socket.readyState === WebSocketImpl.OPEN) // if not completed already and socket is open, send complete message to server on release\n                        socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                            id,\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete\n                        }, replacer));\n                        locks--;\n                        done = true;\n                        release();\n                    };\n                    // either the releaser will be called, connection completed and\n                    // the promise resolved or the socket closed and the promise rejected.\n                    // whatever happens though, we want to stop listening for messages\n                    await waitForReleaseOrThrowOnClose.finally(unlisten);\n                    return; // completed, shouldnt try again\n                } catch (errOrCloseEvent) {\n                    if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n                }\n            }\n        })().then(()=>{\n            // delivering either an error or a complete terminates the sequence\n            if (!errored) sink.complete();\n        }) // resolves on release or normal closure\n        .catch((err)=>{\n            sink.error(err);\n        }); // rejects on close events and errors\n        return ()=>{\n            // dispose only of active subscriptions\n            if (!done) releaser();\n        };\n    }\n    return {\n        on: emitter.on,\n        subscribe,\n        iterate (request) {\n            const pending = [];\n            const deferred = {\n                done: false,\n                error: null,\n                resolve: ()=>{\n                // noop\n                }\n            };\n            const dispose = subscribe(request, {\n                next (val) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    pending.push(val);\n                    deferred.resolve();\n                },\n                error (err) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                },\n                complete () {\n                    deferred.done = true;\n                    deferred.resolve();\n                }\n            });\n            const iterator = function iterator() {\n                return __asyncGenerator(this, arguments, function* iterator_1() {\n                    for(;;){\n                        if (!pending.length) {\n                            // only wait if there are no pending messages available\n                            yield __await(new Promise((resolve)=>deferred.resolve = resolve));\n                        }\n                        // first flush\n                        while(pending.length){\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            yield yield __await(pending.shift());\n                        }\n                        // then error\n                        if (deferred.error) {\n                            throw deferred.error;\n                        }\n                        // or complete\n                        if (deferred.done) {\n                            return yield __await(void 0);\n                        }\n                    }\n                });\n            }();\n            iterator.throw = async (err)=>{\n                if (!deferred.done) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                }\n                return {\n                    done: true,\n                    value: undefined\n                };\n            };\n            iterator.return = async ()=>{\n                dispose();\n                return {\n                    done: true,\n                    value: undefined\n                };\n            };\n            return iterator;\n        },\n        async dispose () {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, \"Normal Closure\");\n            }\n        },\n        terminate () {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit(\"closed\", {\n                    code: 4499,\n                    reason: \"Terminated\",\n                    wasClean: false\n                });\n            }\n        }\n    };\n}\nfunction isLikeCloseEvent(val) {\n    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(val) && \"code\" in val && \"reason\" in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000,\n        1001,\n        1006,\n        1005,\n        1012,\n        1013,\n        1014\n    ].includes(code)) return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return typeof val === \"function\" && \"constructor\" in val && \"CLOSED\" in val && \"CLOSING\" in val && \"CONNECTING\" in val && \"OPEN\" in val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvY2xpZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDRCxJQUFJQSxVQUFVLFNBQUssSUFBSSxTQUFJLENBQUNBLE9BQU8sSUFBSyxTQUFVQyxDQUFDO0lBQUksT0FBTyxJQUFJLFlBQVlELFVBQVcsS0FBSSxDQUFDQyxDQUFDLEdBQUdBLEdBQUcsSUFBSSxJQUFJLElBQUlELFFBQVFDO0FBQUk7QUFDN0gsSUFBSUMsbUJBQW1CLFNBQUssSUFBSSxTQUFJLENBQUNBLGdCQUFnQixJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxTQUFTO0lBQzlGLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxFQUFFLE1BQU0sSUFBSUMsVUFBVTtJQUMvQyxJQUFJQyxJQUFJSixVQUFVSyxLQUFLLENBQUNQLFNBQVNDLGNBQWMsRUFBRSxHQUFHTyxHQUFHQyxJQUFJLEVBQUU7SUFDN0QsT0FBT0QsSUFBSSxDQUFDLEdBQUdFLEtBQUssU0FBU0EsS0FBSyxVQUFVQSxLQUFLLFdBQVdGLENBQUMsQ0FBQ0wsT0FBT0MsYUFBYSxDQUFDLEdBQUc7UUFBYyxPQUFPLElBQUk7SUFBRSxHQUFHSTtJQUNwSCxTQUFTRSxLQUFLQyxDQUFDO1FBQUksSUFBSUwsQ0FBQyxDQUFDSyxFQUFFLEVBQUVILENBQUMsQ0FBQ0csRUFBRSxHQUFHLFNBQVViLENBQUM7WUFBSSxPQUFPLElBQUljLFFBQVEsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO2dCQUFJTCxFQUFFTSxJQUFJLENBQUM7b0JBQUNKO29CQUFHYjtvQkFBR2U7b0JBQUdDO2lCQUFFLElBQUksS0FBS0UsT0FBT0wsR0FBR2I7WUFBSTtRQUFJO0lBQUc7SUFDekksU0FBU2tCLE9BQU9MLENBQUMsRUFBRWIsQ0FBQztRQUFJLElBQUk7WUFBRW1CLEtBQUtYLENBQUMsQ0FBQ0ssRUFBRSxDQUFDYjtRQUFLLEVBQUUsT0FBT29CLEdBQUc7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WDtRQUNBLE1BQU1GO1lBQ0ZqRSxXQUFXO1lBQ1gsSUFBSXBCLFlBQVk7Z0JBQ1oscUNBQXFDO2dCQUNyQyxNQUFNLENBQUN1QixPQUFPLEdBQUcsTUFBTXZCO2dCQUN2QnVCLE9BQU9nQixLQUFLLENBQUMsTUFBTTtZQUN2QjtRQUNKO1FBQ0FxRDtZQUNJLElBQUk1RixZQUFZO2dCQUNaLGdDQUFnQztnQkFDaENSLFFBQVFLLElBQUksQ0FBQyxVQUFVO29CQUNuQjhCLE1BQU07b0JBQ05DLFFBQVE7b0JBQ1JpRSxVQUFVO2dCQUNkO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFDQSxTQUFTMUgsaUJBQWlCbUgsR0FBRztJQUN6QixPQUFPNUksb0RBQVFBLENBQUM0SSxRQUFRLFVBQVVBLE9BQU8sWUFBWUE7QUFDekQ7QUFDQSxTQUFTekIseUJBQXlCbEMsSUFBSTtJQUNsQyxJQUFJO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSCxDQUFDeUMsUUFBUSxDQUFDekMsT0FDUCxPQUFPO0lBQ1gsc0NBQXNDO0lBQ3RDLE9BQU9BLFFBQVEsUUFBUUEsUUFBUTtBQUNuQztBQUNBLFNBQVMxQyxZQUFZcUcsR0FBRztJQUNwQixPQUFRLE9BQU9BLFFBQVEsY0FDbkIsaUJBQWlCQSxPQUNqQixZQUFZQSxPQUNaLGFBQWFBLE9BQ2IsZ0JBQWdCQSxPQUNoQixVQUFVQTtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLXByb2plY3Qtcm9vdC8uL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9jbGllbnQubWpzP2FiOWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogY2xpZW50XG4gKlxuICovXG52YXIgX19hd2FpdCA9ICh0aGlzICYmIHRoaXMuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuaW1wb3J0IHsgR1JBUEhRTF9UUkFOU1BPUlRfV1NfUFJPVE9DT0wsIENsb3NlQ29kZSwgTWVzc2FnZVR5cGUsIHBhcnNlTWVzc2FnZSwgc3RyaW5naWZ5TWVzc2FnZSwgfSBmcm9tICcuL2NvbW1vbi5tanMnO1xuaW1wb3J0IHsgaXNPYmplY3QsIGxpbWl0Q2xvc2VSZWFzb24gfSBmcm9tICcuL3V0aWxzLm1qcyc7XG4vKiogVGhpcyBmaWxlIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgYnJvd3NlcnMsIHJlLWV4cG9ydCBjb21tb24gZWxlbWVudHMuICovXG5leHBvcnQgKiBmcm9tICcuL2NvbW1vbi5tanMnO1xuLyoqXG4gKiBDcmVhdGVzIGEgZGlzcG9zYWJsZSBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDbGllbnQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgdXJsLCBjb25uZWN0aW9uUGFyYW1zLCBsYXp5ID0gdHJ1ZSwgb25Ob25MYXp5RXJyb3IgPSBjb25zb2xlLmVycm9yLCBsYXp5Q2xvc2VUaW1lb3V0OiBsYXp5Q2xvc2VUaW1lb3V0TXMgPSAwLCBrZWVwQWxpdmUgPSAwLCBkaXNhYmxlUG9uZywgY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0ID0gMCwgcmV0cnlBdHRlbXB0cyA9IDUsIHJldHJ5V2FpdCA9IGFzeW5jIGZ1bmN0aW9uIHJhbmRvbWlzZWRFeHBvbmVudGlhbEJhY2tvZmYocmV0cmllcykge1xuICAgICAgICBsZXQgcmV0cnlEZWxheSA9IDEwMDA7IC8vIHN0YXJ0IHdpdGggMXMgZGVsYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXRyaWVzOyBpKyspIHtcbiAgICAgICAgICAgIHJldHJ5RGVsYXkgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5ICtcbiAgICAgICAgICAgIC8vIGFkZCByYW5kb20gdGltZW91dCBmcm9tIDMwMG1zIHRvIDNzXG4gICAgICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoMzAwMCAtIDMwMCkgKyAzMDApKSk7XG4gICAgfSwgc2hvdWxkUmV0cnkgPSBpc0xpa2VDbG9zZUV2ZW50LCBpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0sIG9uLCB3ZWJTb2NrZXRJbXBsLCBcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB2NCBVVUlEIHRvIGJlIHVzZWQgYXMgdGhlIElEIHVzaW5nIGBNYXRoYFxuICAgICAqIGFzIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci4gU3VwcGx5IHlvdXIgb3duIGdlbmVyYXRvclxuICAgICAqIGluIGNhc2UgeW91IG5lZWQgbW9yZSB1bmlxdWVuZXNzLlxuICAgICAqXG4gICAgICogUmVmZXJlbmNlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXG4gICAgICovXG4gICAgZ2VuZXJhdGVJRCA9IGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgICAgIH0pO1xuICAgIH0sIGpzb25NZXNzYWdlUmVwbGFjZXI6IHJlcGxhY2VyLCBqc29uTWVzc2FnZVJldml2ZXI6IHJldml2ZXIsIH0gPSBvcHRpb25zO1xuICAgIGxldCB3cztcbiAgICBpZiAod2ViU29ja2V0SW1wbCkge1xuICAgICAgICBpZiAoIWlzV2ViU29ja2V0KHdlYlNvY2tldEltcGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgd3MgPSB3ZWJTb2NrZXRJbXBsO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3cyA9IFdlYlNvY2tldDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd3MgPVxuICAgICAgICAgICAgZ2xvYmFsLldlYlNvY2tldCB8fFxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFN1cHBvcnQgbW9yZSBicm93c2Vyc1xuICAgICAgICAgICAgICAgIGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdzID1cbiAgICAgICAgICAgIHdpbmRvdy5XZWJTb2NrZXQgfHxcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBTdXBwb3J0IG1vcmUgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICB3aW5kb3cuTW96V2ViU29ja2V0O1xuICAgIH1cbiAgICBpZiAoIXdzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgaW1wbGVtZW50YXRpb24gbWlzc2luZzsgb24gTm9kZSB5b3UgY2FuIGBpbXBvcnQgV2ViU29ja2V0IGZyb20gJ3dzJztgIGFuZCBwYXNzIGB3ZWJTb2NrZXRJbXBsOiBXZWJTb2NrZXRgIHRvIGBjcmVhdGVDbGllbnRgXCIpO1xuICAgIGNvbnN0IFdlYlNvY2tldEltcGwgPSB3cztcbiAgICAvLyB3ZWJzb2NrZXQgc3RhdHVzIGVtaXR0ZXIsIHN1YnNjcmlwdGlvbnMgYXJlIGhhbmRsZWQgZGlmZmVyZW50bHlcbiAgICBjb25zdCBlbWl0dGVyID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb24oaWQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpZF0gPSBsaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbaWRdO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1pdChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdpZCcgaW4gbWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGxpc3RlbmVyc1ttZXNzYWdlLmlkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobGlzdGVuZXJzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgY29ubmVjdGluZzogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5jb25uZWN0aW5nKSA/IFtvbi5jb25uZWN0aW5nXSA6IFtdLFxuICAgICAgICAgICAgb3BlbmVkOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLm9wZW5lZCkgPyBbb24ub3BlbmVkXSA6IFtdLFxuICAgICAgICAgICAgY29ubmVjdGVkOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLmNvbm5lY3RlZCkgPyBbb24uY29ubmVjdGVkXSA6IFtdLFxuICAgICAgICAgICAgcGluZzogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5waW5nKSA/IFtvbi5waW5nXSA6IFtdLFxuICAgICAgICAgICAgcG9uZzogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5wb25nKSA/IFtvbi5wb25nXSA6IFtdLFxuICAgICAgICAgICAgbWVzc2FnZTogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5tZXNzYWdlKSA/IFttZXNzYWdlLmVtaXQsIG9uLm1lc3NhZ2VdIDogW21lc3NhZ2UuZW1pdF0sXG4gICAgICAgICAgICBjbG9zZWQ6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24uY2xvc2VkKSA/IFtvbi5jbG9zZWRdIDogW10sXG4gICAgICAgICAgICBlcnJvcjogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5lcnJvcikgPyBbb24uZXJyb3JdIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvbk1lc3NhZ2U6IG1lc3NhZ2Uub24sXG4gICAgICAgICAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gbGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICBsLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGwuc3BsaWNlKGwuaW5kZXhPZihsaXN0ZW5lciksIDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICAgICAgICAgIC8vIHdlIGNvcHkgdGhlIGxpc3RlbmVycyBzbyB0aGF0IHVubGlzdGVucyBkb250IFwicHVsbCB0aGUgcnVnIHVuZGVyIG91ciBmZWV0XCJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIFsuLi5saXN0ZW5lcnNbZXZlbnRdXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBUaGUgYXJncyBzaG91bGQgZml0XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICAvLyBpbnZva2VzIHRoZSBjYWxsYmFjayBlaXRoZXIgd2hlbiBhbiBlcnJvciBvciBjbG9zZWQgZXZlbnQgaXMgZW1pdHRlZCxcbiAgICAvLyBmaXJzdCBvbmUgdGhhdCBnZXRzIGNhbGxlZCBwcmV2YWlscywgb3RoZXIgZW1pc3Npb25zIGFyZSBpZ25vcmVkXG4gICAgZnVuY3Rpb24gZXJyb3JPckNsb3NlZChjYikge1xuICAgICAgICBjb25zdCBsaXN0ZW5pbmcgPSBbXG4gICAgICAgICAgICAvLyBlcnJvcnMgYXJlIGZhdGFsIGFuZCBtb3JlIGNyaXRpY2FsIHRoYW4gY2xvc2UgZXZlbnRzLCB0aHJvdyB0aGVtIGZpcnN0XG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5pbmcuZm9yRWFjaCgodW5saXN0ZW4pID0+IHVubGlzdGVuKCkpO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8vIGNsb3NlcyBjYW4gYmUgZ3JhY2VmdWwgYW5kIG5vdCBmYXRhbCwgdGhyb3cgdGhlbSBzZWNvbmQgKGlmIGVycm9yIGRpZG50IHRocm93KVxuICAgICAgICAgICAgZW1pdHRlci5vbignY2xvc2VkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuaW5nLmZvckVhY2goKHVubGlzdGVuKSA9PiB1bmxpc3RlbigpKTtcbiAgICAgICAgICAgICAgICBjYihldmVudCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbGV0IGNvbm5lY3RpbmcsIGxvY2tzID0gMCwgbGF6eUNsb3NlVGltZW91dCwgcmV0cnlpbmcgPSBmYWxzZSwgcmV0cmllcyA9IDAsIGRpc3Bvc2VkID0gZmFsc2U7XG4gICAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgICAgLy8gY2xlYXIgdGhlIGxhenkgY2xvc2UgdGltZW91dCBpbW1lZGlhdGVsbHkgc28gdGhhdCBjbG9zZSBnZXRzIGRlYm91bmNlZFxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lbmlzZGVuam8vZ3JhcGhxbC13cy9pc3N1ZXMvMzg4XG4gICAgICAgIGNsZWFyVGltZW91dChsYXp5Q2xvc2VUaW1lb3V0KTtcbiAgICAgICAgY29uc3QgW3NvY2tldCwgdGhyb3dPbkNsb3NlXSA9IGF3YWl0IChjb25uZWN0aW5nICE9PSBudWxsICYmIGNvbm5lY3RpbmcgIT09IHZvaWQgMCA/IGNvbm5lY3RpbmcgOiAoY29ubmVjdGluZyA9IG5ldyBQcm9taXNlKChjb25uZWN0ZWQsIGRlbmllZCkgPT4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXRyeWluZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJldHJ5V2FpdChyZXRyaWVzKTtcbiAgICAgICAgICAgICAgICAvLyBzdWJzY3JpcHRpb25zIG1pZ2h0IGNvbXBsZXRlIHdoaWxlIHdhaXRpbmcgZm9yIHJldHJ5XG4gICAgICAgICAgICAgICAgaWYgKCFsb2Nrcykge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVuaWVkKHsgY29kZTogMTAwMCwgcmVhc29uOiAnQWxsIFN1YnNjcmlwdGlvbnMgR29uZScgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IFdlYlNvY2tldEltcGwodHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJyA/IGF3YWl0IHVybCgpIDogdXJsLCBHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCk7XG4gICAgICAgICAgICBsZXQgY29ubmVjdGlvbkFja1RpbWVvdXQsIHF1ZXVlZFBpbmc7XG4gICAgICAgICAgICBmdW5jdGlvbiBlbnF1ZXVlUGluZygpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoa2VlcEFsaXZlKSAmJiBrZWVwQWxpdmUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChxdWV1ZWRQaW5nKTsgLy8gaW4gY2FzZSB3aGVyZSBhIHBvbmcgd2FzIHJlY2VpdmVkIGJlZm9yZSBhIHBpbmcgKHRoaXMgaXMgdmFsaWQgYmVoYXZpb3VyKVxuICAgICAgICAgICAgICAgICAgICBxdWV1ZWRQaW5nID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2UoeyB0eXBlOiBNZXNzYWdlVHlwZS5QaW5nIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3BpbmcnLCBmYWxzZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwga2VlcEFsaXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvck9yQ2xvc2VkKChlcnJPckV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbkFja1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChxdWV1ZWRQaW5nKTtcbiAgICAgICAgICAgICAgICBkZW5pZWQoZXJyT3JFdmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGlrZUNsb3NlRXZlbnQoZXJyT3JFdmVudCkgJiYgZXJyT3JFdmVudC5jb2RlID09PSA0NDk5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSg0NDk5LCAnVGVybWluYXRlZCcpOyAvLyBjbG9zZSBldmVudCBpcyBhcnRpZmljaWFsIGFuZCBlbWl0dGVkIG1hbnVhbGx5LCBzZWUgYENsaWVudC50ZXJtaW5hdGUoKWAgYmVsb3dcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzb2NrZXQub25lcnJvciA9IChlcnIpID0+IGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgc29ja2V0Lm9uY2xvc2UgPSAoZXZlbnQpID0+IGVtaXR0ZXIuZW1pdCgnY2xvc2VkJywgZXZlbnQpO1xuICAgICAgICAgICAgc29ja2V0Lm9ub3BlbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ29wZW5lZCcsIHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0eXBlb2YgY29ubmVjdGlvblBhcmFtcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBjb25uZWN0aW9uUGFyYW1zKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29ubmVjdGlvblBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvblBhcmFtcyBtaWdodCB0YWtlIHRvbyBsb25nIGNhdXNpbmcgdGhlIHNlcnZlciB0byBraWNrIG9mZiB0aGUgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZWNlc3NhcnkgZXJyb3IvY2xvc2UgZXZlbnQgaXMgYWxyZWFkeSByZXBvcnRlZCAtIHNpbXBseSBzdG9wIGV4ZWN1dGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldEltcGwuT1BFTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc3RyaW5naWZ5TWVzc2FnZShwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5Db25uZWN0aW9uSW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpcyBjb21wbGV0ZWx5IGFic2VudCBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlcGxhY2VyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZShDbG9zZUNvZGUuQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXQsICdDb25uZWN0aW9uIGFja25vd2xlZGdlbWVudCB0aW1lb3V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVucXVldWVQaW5nKCk7IC8vIGVucXVldWUgcGluZyAobm9vcCBpZiBkaXNhYmxlZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKENsb3NlQ29kZS5JbnRlcm5hbENsaWVudEVycm9yLCBsaW1pdENsb3NlUmVhc29uKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBuZXcgRXJyb3IoZXJyKS5tZXNzYWdlLCAnSW50ZXJuYWwgY2xpZW50IGVycm9yJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYWNrbm93bGVkZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzb2NrZXQub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHBhcnNlTWVzc2FnZShkYXRhLCByZXZpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdwaW5nJyB8fCBtZXNzYWdlLnR5cGUgPT09ICdwb25nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KG1lc3NhZ2UudHlwZSwgdHJ1ZSwgbWVzc2FnZS5wYXlsb2FkKTsgLy8gcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdwb25nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVucXVldWVQaW5nKCk7IC8vIGVucXVldWUgbmV4dCBwaW5nIChub29wIGlmIGRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVQb25nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uZCB3aXRoIHBvbmcgb24gcGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2UobWVzc2FnZS5wYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuUG9uZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG1lc3NhZ2UucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlBvbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGlzIGNvbXBsZXRlbHkgYWJzZW50IGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdwb25nJywgZmFsc2UsIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHBpbmcgYW5kIHBvbmdzIGNhbiBiZSByZWNlaXZlZCB3aGVuZXZlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2tub3dsZWRnZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgY29ubmVjdGVkIGFuZCBhY2tub3dsZWRnZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmlyc3QgbWVzc2FnZSBjYW5ub3QgYmUgb2YgdHlwZSAke21lc3NhZ2UudHlwZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BY2tUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgYWNrbm93bGVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdjb25uZWN0ZWQnLCBzb2NrZXQsIG1lc3NhZ2UucGF5bG9hZCk7IC8vIGNvbm5lY3RlZCA9IHNvY2tldCBvcGVuZWQgKyBhY2tub3dsZWRnZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlpbmcgPSBmYWxzZTsgLy8gZnV0dXJlIGxhenkgY29ubmVjdHMgYXJlIG5vdCByZXRyaWVzXG4gICAgICAgICAgICAgICAgICAgIHJldHJpZXMgPSAwOyAvLyByZXNldCB0aGUgcmV0cmllcyBvbiBjb25uZWN0XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZChbXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBlcnJvck9yQ2xvc2VkKHJlamVjdCkpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25tZXNzYWdlID0gbnVsbDsgLy8gc3RvcCByZWFkaW5nIG1lc3NhZ2VzIGFzIHNvb24gYXMgcmVhZGluZyBicmVha3Mgb25jZVxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKENsb3NlQ29kZS5CYWRSZXNwb25zZSwgbGltaXRDbG9zZVJlYXNvbihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogbmV3IEVycm9yKGVycikubWVzc2FnZSwgJ0JhZCByZXNwb25zZScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpKSkpO1xuICAgICAgICAvLyBpZiB0aGUgcHJvdmlkZWQgc29ja2V0IGlzIGluIGEgY2xvc2luZyBzdGF0ZSwgd2FpdCBmb3IgdGhlIHRocm93IG9uIGNsb3NlXG4gICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5DTE9TSU5HKVxuICAgICAgICAgICAgYXdhaXQgdGhyb3dPbkNsb3NlO1xuICAgICAgICBsZXQgcmVsZWFzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHJlbGVhc2VzIHRoaXMgY29ubmVjdGlvblxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWxlYXNlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAocmVsZWFzZSA9IHJlc29sdmUpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIHJlbGVhc2UsXG4gICAgICAgICAgICBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yXG4gICAgICAgICAgICAgICAgcmVsZWFzZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9ja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpZiBubyBtb3JlIGxvY2tzIGFyZSBwcmVzZW50LCBjb21wbGV0ZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiBzb2NrZXQuY2xvc2UoMTAwMCwgJ05vcm1hbCBDbG9zdXJlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUobGF6eUNsb3NlVGltZW91dE1zKSAmJiBsYXp5Q2xvc2VUaW1lb3V0TXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGtlZXBhbGl2ZSBpcyBzZXQsIGFsbG93IGZvciB0aGUgc3BlY2lmaWVkIGNhbG1kb3duIHRpbWUgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBjb21wbGV0ZSBpZiB0aGUgc29ja2V0IGlzIHN0aWxsIG9wZW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF6eUNsb3NlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbGF6eUNsb3NlVGltZW91dE1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjb21wbGV0ZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvLyBvclxuICAgICAgICAgICAgICAgIHRocm93T25DbG9zZSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGBjb25uZWN0YCBwcm9ibGVtIGFuZCBldmFsdWF0ZXMgaWYgdGhlIGNsaWVudCBzaG91bGQgcmV0cnkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvdWxkUmV0cnlDb25uZWN0T3JUaHJvdyhlcnJPckNsb3NlRXZlbnQpIHtcbiAgICAgICAgLy8gc29tZSBjbG9zZSBjb2RlcyBhcmUgd29ydGggcmVwb3J0aW5nIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmIChpc0xpa2VDbG9zZUV2ZW50KGVyck9yQ2xvc2VFdmVudCkgJiZcbiAgICAgICAgICAgIChpc0ZhdGFsSW50ZXJuYWxDbG9zZUNvZGUoZXJyT3JDbG9zZUV2ZW50LmNvZGUpIHx8XG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuSW50ZXJuYWxTZXJ2ZXJFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLkludGVybmFsQ2xpZW50RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5CYWRSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuQmFkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5VbmF1dGhvcml6ZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIENsb3NlQ29kZS5Gb3JiaWRkZW4sIG1pZ2h0IGdyYW50IGFjY2VzcyBvdXQgYWZ0ZXIgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLlN1YnByb3RvY29sTm90QWNjZXB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2VDb2RlLkNvbm5lY3Rpb25Jbml0aWFsaXNhdGlvblRpbWVvdXQsIG1pZ2h0IG5vdCB0aW1lIG91dCBhZnRlciByZXRyeVxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZUNvZGUuQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXQsIG1pZ2h0IG5vdCB0aW1lIG91dCBhZnRlciByZXRyeVxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuU3Vic2NyaWJlckFscmVhZHlFeGlzdHMsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5Ub29NYW55SW5pdGlhbGlzYXRpb25SZXF1ZXN0cyxcbiAgICAgICAgICAgICAgICAgICAgLy8gNDQ5OSwgLy8gVGVybWluYXRlZCwgcHJvYmFibHkgYmVjYXVzZSB0aGUgc29ja2V0IGZyb3plLCB3ZSB3YW50IHRvIHJldHJ5XG4gICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhlcnJPckNsb3NlRXZlbnQuY29kZSkpKVxuICAgICAgICAgICAgdGhyb3cgZXJyT3JDbG9zZUV2ZW50O1xuICAgICAgICAvLyBjbGllbnQgd2FzIGRpc3Bvc2VkLCBubyByZXRyaWVzIHNob3VsZCBwcm9jZWVkIHJlZ2FyZGxlc3NcbiAgICAgICAgaWYgKGRpc3Bvc2VkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBub3JtYWwgY2xvc3VyZSAocG9zc2libHkgYWxsIHN1YnNjcmlwdGlvbnMgaGF2ZSBjb21wbGV0ZWQpXG4gICAgICAgIC8vIGlmIG5vIGxvY2tzIHdlcmUgYWNxdWlyZWQgaW4gdGhlIG1lYW50aW1lLCBzaG91bGRudCB0cnkgYWdhaW5cbiAgICAgICAgaWYgKGlzTGlrZUNsb3NlRXZlbnQoZXJyT3JDbG9zZUV2ZW50KSAmJiBlcnJPckNsb3NlRXZlbnQuY29kZSA9PT0gMTAwMClcbiAgICAgICAgICAgIHJldHVybiBsb2NrcyA+IDA7XG4gICAgICAgIC8vIHJldHJpZXMgYXJlIG5vdCBhbGxvd2VkIG9yIHdlIHRyaWVkIHRvIG1hbnkgdGltZXMsIHJlcG9ydCBlcnJvclxuICAgICAgICBpZiAoIXJldHJ5QXR0ZW1wdHMgfHwgcmV0cmllcyA+PSByZXRyeUF0dGVtcHRzKVxuICAgICAgICAgICAgdGhyb3cgZXJyT3JDbG9zZUV2ZW50O1xuICAgICAgICAvLyB0aHJvdyBub24tcmV0cnlhYmxlIGNvbm5lY3Rpb24gcHJvYmxlbXNcbiAgICAgICAgaWYgKCFzaG91bGRSZXRyeShlcnJPckNsb3NlRXZlbnQpKVxuICAgICAgICAgICAgdGhyb3cgZXJyT3JDbG9zZUV2ZW50O1xuICAgICAgICAvLyBAZGVwcmVjYXRlZCB0aHJvdyBmYXRhbCBjb25uZWN0aW9uIHByb2JsZW1zIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmIChpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0gPT09IG51bGwgfHwgaXNGYXRhbENvbm5lY3Rpb25Qcm9ibGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0oZXJyT3JDbG9zZUV2ZW50KSlcbiAgICAgICAgICAgIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICAgICAgLy8gbG9va3MgZ29vZCwgc3RhcnQgcmV0cnlpbmdcbiAgICAgICAgcmV0dXJuIChyZXRyeWluZyA9IHRydWUpO1xuICAgIH1cbiAgICAvLyBpbiBub24tbGF6eSAoaG90PykgbW9kZSBhbHdheXMgaG9sZCBvbmUgY29ubmVjdGlvbiBsb2NrIHRvIHBlcnNpc3QgdGhlIHNvY2tldFxuICAgIGlmICghbGF6eSkge1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9ja3MrKztcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbLCAsIHRocm93T25DbG9zZV0gPSBhd2FpdCBjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRocm93T25DbG9zZTsgLy8gd2lsbCBhbHdheXMgdGhyb3cgYmVjYXVzZSByZWxlYXNlciBpcyBub3QgdXNlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyT3JDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3coZXJyT3JDbG9zZUV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVyck9yQ2xvc2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwb3J0IHRocm93biBlcnJvciwgbm8gZnVydGhlciByZXRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25Ob25MYXp5RXJyb3IgPT09IG51bGwgfHwgb25Ob25MYXp5RXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTm9uTGF6eUVycm9yKGVyck9yQ2xvc2VFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShwYXlsb2FkLCBzaW5rKSB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVJRChwYXlsb2FkKTtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZSwgZXJyb3JlZCA9IGZhbHNlLCByZWxlYXNlciA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGZvciBoYW5kbGluZyBjb21wbGV0aW9ucyBiZWZvcmUgY29ubmVjdFxuICAgICAgICAgICAgbG9ja3MtLTtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9ja3MrKztcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbc29ja2V0LCByZWxlYXNlLCB3YWl0Rm9yUmVsZWFzZU9yVGhyb3dPbkNsb3NlXSA9IGF3YWl0IGNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZG9uZSB3aGlsZSB3YWl0aW5nIGZvciBjb25uZWN0LCByZWxlYXNlIHRoZSBjb25uZWN0aW9uIGxvY2sgcmlnaHQgYXdheVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVubGlzdGVuID0gZW1pdHRlci5vbk1lc3NhZ2UoaWQsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuTmV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBwYXlsb2FkIHdpbGwgZml0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luay5uZXh0KG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5FcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3JlZCA9IHRydWUpLCAoZG9uZSA9IHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLmVycm9yKG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Db21wbGV0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZXIoKTsgLy8gcmVsZWFzZSBjb21wbGV0ZXMgdGhlIHNpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TdWJzY3JpYmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICB9LCByZXBsYWNlcikpO1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSAmJiBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5PUEVOKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBjb21wbGV0ZWQgYWxyZWFkeSBhbmQgc29ja2V0IGlzIG9wZW4sIHNlbmQgY29tcGxldGUgbWVzc2FnZSB0byBzZXJ2ZXIgb24gcmVsZWFzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ29tcGxldGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVwbGFjZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2tzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWl0aGVyIHRoZSByZWxlYXNlciB3aWxsIGJlIGNhbGxlZCwgY29ubmVjdGlvbiBjb21wbGV0ZWQgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcm9taXNlIHJlc29sdmVkIG9yIHRoZSBzb2NrZXQgY2xvc2VkIGFuZCB0aGUgcHJvbWlzZSByZWplY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hhdGV2ZXIgaGFwcGVucyB0aG91Z2gsIHdlIHdhbnQgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JSZWxlYXNlT3JUaHJvd09uQ2xvc2UuZmluYWxseSh1bmxpc3Rlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gY29tcGxldGVkLCBzaG91bGRudCB0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVyck9yQ2xvc2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3coZXJyT3JDbG9zZUV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGRlbGl2ZXJpbmcgZWl0aGVyIGFuIGVycm9yIG9yIGEgY29tcGxldGUgdGVybWluYXRlcyB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIGlmICghZXJyb3JlZClcbiAgICAgICAgICAgICAgICBzaW5rLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pIC8vIHJlc29sdmVzIG9uIHJlbGVhc2Ugb3Igbm9ybWFsIGNsb3N1cmVcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBzaW5rLmVycm9yKGVycik7XG4gICAgICAgIH0pOyAvLyByZWplY3RzIG9uIGNsb3NlIGV2ZW50cyBhbmQgZXJyb3JzXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBkaXNwb3NlIG9ubHkgb2YgYWN0aXZlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZWxlYXNlcigpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBvbjogZW1pdHRlci5vbixcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBpdGVyYXRlKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0ge1xuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZGlzcG9zZSA9IHN1YnNjcmliZShyZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbmV4dCh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gKGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIGl0ZXJhdG9yXzEoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVuZGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHdhaXQgaWYgdGhlcmUgYXJlIG5vIHBlbmRpbmcgbWVzc2FnZXMgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgX19hd2FpdChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gKGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgZmx1c2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChwZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChwZW5kaW5nLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmVycmVkLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVmZXJyZWQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBjb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmVycmVkLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX19hd2FpdCh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgaXRlcmF0b3IudGhyb3cgPSBhc3luYyAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWZlcnJlZC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXRlcmF0b3IucmV0dXJuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBkaXNwb3NlKCkge1xuICAgICAgICAgICAgZGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIGNvbm5lY3Rpb24sIGNsb3NlIGl0XG4gICAgICAgICAgICAgICAgY29uc3QgW3NvY2tldF0gPSBhd2FpdCBjb25uZWN0aW5nO1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgxMDAwLCAnTm9ybWFsIENsb3N1cmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGVybWluYXRlKCkge1xuICAgICAgICAgICAgaWYgKGNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnY2xvc2VkJywge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiA0NDk5LFxuICAgICAgICAgICAgICAgICAgICByZWFzb246ICdUZXJtaW5hdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgd2FzQ2xlYW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBpc0xpa2VDbG9zZUV2ZW50KHZhbCkge1xuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmICdjb2RlJyBpbiB2YWwgJiYgJ3JlYXNvbicgaW4gdmFsO1xufVxuZnVuY3Rpb24gaXNGYXRhbEludGVybmFsQ2xvc2VDb2RlKGNvZGUpIHtcbiAgICBpZiAoW1xuICAgICAgICAxMDAwLFxuICAgICAgICAxMDAxLFxuICAgICAgICAxMDA2LFxuICAgICAgICAxMDA1LFxuICAgICAgICAxMDEyLFxuICAgICAgICAxMDEzLFxuICAgICAgICAxMDE0LCAvLyBCYWQgR2F0ZXdheVxuICAgIF0uaW5jbHVkZXMoY29kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBhbGwgb3RoZXIgaW50ZXJuYWwgZXJyb3JzIGFyZSBmYXRhbFxuICAgIHJldHVybiBjb2RlID49IDEwMDAgJiYgY29kZSA8PSAxOTk5O1xufVxuZnVuY3Rpb24gaXNXZWJTb2NrZXQodmFsKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICdjb25zdHJ1Y3RvcicgaW4gdmFsICYmXG4gICAgICAgICdDTE9TRUQnIGluIHZhbCAmJlxuICAgICAgICAnQ0xPU0lORycgaW4gdmFsICYmXG4gICAgICAgICdDT05ORUNUSU5HJyBpbiB2YWwgJiZcbiAgICAgICAgJ09QRU4nIGluIHZhbCk7XG59XG4iXSwibmFtZXMiOlsiX19hd2FpdCIsInYiLCJfX2FzeW5jR2VuZXJhdG9yIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJnZW5lcmF0b3IiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiVHlwZUVycm9yIiwiZyIsImFwcGx5IiwiaSIsInEiLCJ2ZXJiIiwibiIsIlByb21pc2UiLCJhIiwiYiIsInB1c2giLCJyZXN1bWUiLCJzdGVwIiwiZSIsInNldHRsZSIsInIiLCJ2YWx1ZSIsInJlc29sdmUiLCJ0aGVuIiwiZnVsZmlsbCIsInJlamVjdCIsImYiLCJzaGlmdCIsImxlbmd0aCIsIkdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MIiwiQ2xvc2VDb2RlIiwiTWVzc2FnZVR5cGUiLCJwYXJzZU1lc3NhZ2UiLCJzdHJpbmdpZnlNZXNzYWdlIiwiaXNPYmplY3QiLCJsaW1pdENsb3NlUmVhc29uIiwiY3JlYXRlQ2xpZW50Iiwib3B0aW9ucyIsInVybCIsImNvbm5lY3Rpb25QYXJhbXMiLCJsYXp5Iiwib25Ob25MYXp5RXJyb3IiLCJjb25zb2xlIiwiZXJyb3IiLCJsYXp5Q2xvc2VUaW1lb3V0IiwibGF6eUNsb3NlVGltZW91dE1zIiwia2VlcEFsaXZlIiwiZGlzYWJsZVBvbmciLCJjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQiLCJyZXRyeUF0dGVtcHRzIiwicmV0cnlXYWl0IiwicmFuZG9taXNlZEV4cG9uZW50aWFsQmFja29mZiIsInJldHJpZXMiLCJyZXRyeURlbGF5Iiwic2V0VGltZW91dCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInNob3VsZFJldHJ5IiwiaXNMaWtlQ2xvc2VFdmVudCIsImlzRmF0YWxDb25uZWN0aW9uUHJvYmxlbSIsIm9uIiwid2ViU29ja2V0SW1wbCIsImdlbmVyYXRlSUQiLCJnZW5lcmF0ZVVVSUQiLCJyZXBsYWNlIiwiYyIsInRvU3RyaW5nIiwianNvbk1lc3NhZ2VSZXBsYWNlciIsInJlcGxhY2VyIiwianNvbk1lc3NhZ2VSZXZpdmVyIiwicmV2aXZlciIsIndzIiwiaXNXZWJTb2NrZXQiLCJFcnJvciIsIldlYlNvY2tldCIsImdsb2JhbCIsIk1veldlYlNvY2tldCIsIndpbmRvdyIsIldlYlNvY2tldEltcGwiLCJlbWl0dGVyIiwibWVzc2FnZSIsImxpc3RlbmVycyIsImlkIiwibGlzdGVuZXIiLCJlbWl0IiwiX2EiLCJjYWxsIiwiY29ubmVjdGluZyIsIm9wZW5lZCIsImNvbm5lY3RlZCIsInBpbmciLCJwb25nIiwiY2xvc2VkIiwib25NZXNzYWdlIiwiZXZlbnQiLCJsIiwic3BsaWNlIiwiaW5kZXhPZiIsImFyZ3MiLCJlcnJvck9yQ2xvc2VkIiwiY2IiLCJsaXN0ZW5pbmciLCJlcnIiLCJmb3JFYWNoIiwidW5saXN0ZW4iLCJsb2NrcyIsInJldHJ5aW5nIiwiZGlzcG9zZWQiLCJjb25uZWN0IiwiY2xlYXJUaW1lb3V0Iiwic29ja2V0IiwidGhyb3dPbkNsb3NlIiwiZGVuaWVkIiwidW5kZWZpbmVkIiwiY29kZSIsInJlYXNvbiIsImNvbm5lY3Rpb25BY2tUaW1lb3V0IiwicXVldWVkUGluZyIsImVucXVldWVQaW5nIiwiaXNGaW5pdGUiLCJyZWFkeVN0YXRlIiwiT1BFTiIsInNlbmQiLCJ0eXBlIiwiUGluZyIsImVyck9yRXZlbnQiLCJjbG9zZSIsIm9uZXJyb3IiLCJvbmNsb3NlIiwib25vcGVuIiwicGF5bG9hZCIsIkNvbm5lY3Rpb25Jbml0IiwiQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXQiLCJJbnRlcm5hbENsaWVudEVycm9yIiwiYWNrbm93bGVkZ2VkIiwib25tZXNzYWdlIiwiZGF0YSIsIlBvbmciLCJDb25uZWN0aW9uQWNrIiwiXyIsIkJhZFJlc3BvbnNlIiwiQ0xPU0lORyIsInJlbGVhc2UiLCJyZWxlYXNlZCIsInJhY2UiLCJjb21wbGV0ZSIsInNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3ciLCJlcnJPckNsb3NlRXZlbnQiLCJpc0ZhdGFsSW50ZXJuYWxDbG9zZUNvZGUiLCJJbnRlcm5hbFNlcnZlckVycm9yIiwiQmFkUmVxdWVzdCIsIlVuYXV0aG9yaXplZCIsIlN1YnByb3RvY29sTm90QWNjZXB0YWJsZSIsIlN1YnNjcmliZXJBbHJlYWR5RXhpc3RzIiwiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHMiLCJpbmNsdWRlcyIsInN1YnNjcmliZSIsInNpbmsiLCJkb25lIiwiZXJyb3JlZCIsInJlbGVhc2VyIiwid2FpdEZvclJlbGVhc2VPclRocm93T25DbG9zZSIsIk5leHQiLCJuZXh0IiwiQ29tcGxldGUiLCJTdWJzY3JpYmUiLCJmaW5hbGx5IiwiY2F0Y2giLCJpdGVyYXRlIiwicmVxdWVzdCIsInBlbmRpbmciLCJkZWZlcnJlZCIsImRpc3Bvc2UiLCJ2YWwiLCJpdGVyYXRvciIsImFyZ3VtZW50cyIsIml0ZXJhdG9yXzEiLCJ0aHJvdyIsInJldHVybiIsInRlcm1pbmF0ZSIsIndhc0NsZWFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphql-ws/lib/client.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphql-ws/lib/common.mjs":
/*!************************************************!*\
  !*** ./node_modules/graphql-ws/lib/common.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* binding */ CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* binding */ DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* binding */ GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   isMessage: () => (/* binding */ isMessage),\n/* harmony export */   parseMessage: () => (/* binding */ parseMessage),\n/* harmony export */   stringifyMessage: () => (/* binding */ stringifyMessage),\n/* harmony export */   validateMessage: () => (/* binding */ validateMessage)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/graphql-ws/lib/utils.mjs\");\n/**\n *\n * common\n *\n */ \n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */ const GRAPHQL_TRANSPORT_WS_PROTOCOL = \"graphql-transport-ws\";\n/**\n * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n *\n * @private\n */ const DEPRECATED_GRAPHQL_WS_PROTOCOL = \"graphql-ws\";\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */ var CloseCode;\n(function(CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */ CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */ CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n})(CloseCode || (CloseCode = {}));\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */ var MessageType;\n(function(MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n})(MessageType || (MessageType = {}));\n/**\n * Validates the message against the GraphQL over WebSocket Protocol.\n *\n * Invalid messages will throw descriptive errors.\n *\n * @category Common\n */ function validateMessage(val) {\n    if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val)) {\n        throw new Error(`Message is expected to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val)}`);\n    }\n    if (!val.type) {\n        throw new Error(`Message is missing the 'type' property`);\n    }\n    if (typeof val.type !== \"string\") {\n        throw new Error(`Message is expects the 'type' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.type)}`);\n    }\n    switch(val.type){\n        case MessageType.ConnectionInit:\n        case MessageType.ConnectionAck:\n        case MessageType.Ping:\n        case MessageType.Pong:\n            {\n                if (val.payload != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object or nullish or missing, but got \"${val.payload}\"`);\n                }\n                break;\n            }\n        case MessageType.Subscribe:\n            {\n                if (typeof val.id !== \"string\") {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n                }\n                if (typeof val.payload.query !== \"string\") {\n                    throw new Error(`\"${val.type}\" message payload expects the 'query' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.query)}`);\n                }\n                if (val.payload.variables != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.variables)) {\n                    throw new Error(`\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.variables)}`);\n                }\n                if (val.payload.operationName != null && (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName) !== \"string\") {\n                    throw new Error(`\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName)}`);\n                }\n                if (val.payload.extensions != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.extensions)) {\n                    throw new Error(`\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.extensions)}`);\n                }\n                break;\n            }\n        case MessageType.Next:\n            {\n                if (typeof val.id !== \"string\") {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n                }\n                break;\n            }\n        case MessageType.Error:\n            {\n                if (typeof val.id !== \"string\") {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.areGraphQLErrors)(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);\n                }\n                break;\n            }\n        case MessageType.Complete:\n            {\n                if (typeof val.id !== \"string\") {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                break;\n            }\n        default:\n            throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n    }\n    return val;\n}\n/**\n * Checks if the provided value is a valid GraphQL over WebSocket message.\n *\n * @deprecated Use `validateMessage` instead.\n *\n * @category Common\n */ function isMessage(val) {\n    try {\n        validateMessage(val);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */ function parseMessage(data, reviver) {\n    return validateMessage(typeof data === \"string\" ? JSON.parse(data, reviver) : data);\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */ function stringifyMessage(msg, replacer) {\n    validateMessage(msg);\n    return JSON.stringify(msg, replacer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvY29tbW9uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ3dFO0FBQ3pFOzs7O0NBSUMsR0FDTSxNQUFNRyxnQ0FBZ0MsdUJBQXVCO0FBQ3BFOzs7O0NBSUMsR0FDTSxNQUFNQyxpQ0FBaUMsYUFBYTtBQUMzRDs7OztDQUlDLEdBQ00sSUFBSUMsVUFBVTtBQUNwQixVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxzQkFBc0IsR0FBRyxLQUFLLEdBQUc7SUFDckRBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLHNCQUFzQixHQUFHLEtBQUssR0FBRztJQUNyREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsYUFBYSxHQUFHLEtBQUssR0FBRztJQUM1Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsY0FBYyxHQUFHLEtBQUssR0FBRztJQUM3Qyx5Q0FBeUMsR0FDekNBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLGVBQWUsR0FBRyxLQUFLLEdBQUc7SUFDOUNBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFlBQVksR0FBRyxLQUFLLEdBQUc7SUFDM0NBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLDJCQUEyQixHQUFHLEtBQUssR0FBRztJQUMxREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsa0NBQWtDLEdBQUcsS0FBSyxHQUFHO0lBQ2pFQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxtQ0FBbUMsR0FBRyxLQUFLLEdBQUc7SUFDbEUsNkNBQTZDLEdBQzdDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQywwQkFBMEIsR0FBRyxLQUFLLEdBQUc7SUFDekRBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLGdDQUFnQyxHQUFHLEtBQUssR0FBRztBQUNuRSxHQUFHQSxhQUFjQSxDQUFBQSxZQUFZLENBQUM7QUFDOUI7Ozs7Q0FJQyxHQUNNLElBQUlDLFlBQVk7QUFDdEIsVUFBVUEsV0FBVztJQUNsQkEsV0FBVyxDQUFD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QixTQUFTLFdBQVdOLEtBQUtRLEtBQUssQ0FBQ0YsTUFBTUMsV0FBV0Q7QUFDbEY7QUFDQTs7OztDQUlDLEdBQ00sU0FBU0csaUJBQWlCQyxHQUFHLEVBQUVDLFFBQVE7SUFDMUMzQixnQkFBZ0IwQjtJQUNoQixPQUFPVixLQUFLQyxTQUFTLENBQUNTLEtBQUtDO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52b2ljZS1hcHAtcHJvamVjdC1yb290Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL2NvbW1vbi5tanM/MDYxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBjb21tb25cbiAqXG4gKi9cbmltcG9ydCB7IGFyZUdyYXBoUUxFcnJvcnMsIGV4dGVuZGVkVHlwZW9mLCBpc09iamVjdCB9IGZyb20gJy4vdXRpbHMubWpzJztcbi8qKlxuICogVGhlIFdlYlNvY2tldCBzdWItcHJvdG9jb2wgdXNlZCBmb3IgdGhlIFtHcmFwaFFMIG92ZXIgV2ViU29ja2V0IFByb3RvY29sXShodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLW92ZXItaHR0cC9ibG9iL21haW4vcmZjcy9HcmFwaFFMT3ZlcldlYlNvY2tldC5tZCkuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgY29uc3QgR1JBUEhRTF9UUkFOU1BPUlRfV1NfUFJPVE9DT0wgPSAnZ3JhcGhxbC10cmFuc3BvcnQtd3MnO1xuLyoqXG4gKiBUaGUgZGVwcmVjYXRlZCBzdWJwcm90b2NvbCB1c2VkIGJ5IFtzdWJzY3JpcHRpb25zLXRyYW5zcG9ydC13c10oaHR0cHM6Ly9naXRodWIuY29tL2Fwb2xsb2dyYXBocWwvc3Vic2NyaXB0aW9ucy10cmFuc3BvcnQtd3MpLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBERVBSRUNBVEVEX0dSQVBIUUxfV1NfUFJPVE9DT0wgPSAnZ3JhcGhxbC13cyc7XG4vKipcbiAqIGBncmFwaHFsLXdzYCBleHBlY3RlZCBhbmQgc3RhbmRhcmQgY2xvc2UgY29kZXMgb2YgdGhlIFtHcmFwaFFMIG92ZXIgV2ViU29ja2V0IFByb3RvY29sXShodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLW92ZXItaHR0cC9ibG9iL21haW4vcmZjcy9HcmFwaFFMT3ZlcldlYlNvY2tldC5tZCkuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgdmFyIENsb3NlQ29kZTtcbihmdW5jdGlvbiAoQ2xvc2VDb2RlKSB7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkludGVybmFsU2VydmVyRXJyb3JcIl0gPSA0NTAwXSA9IFwiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJJbnRlcm5hbENsaWVudEVycm9yXCJdID0gNDAwNV0gPSBcIkludGVybmFsQ2xpZW50RXJyb3JcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiQmFkUmVxdWVzdFwiXSA9IDQ0MDBdID0gXCJCYWRSZXF1ZXN0XCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkJhZFJlc3BvbnNlXCJdID0gNDAwNF0gPSBcIkJhZFJlc3BvbnNlXCI7XG4gICAgLyoqIFRyaWVkIHN1YnNjcmliaW5nIGJlZm9yZSBjb25uZWN0IGFjayAqL1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJVbmF1dGhvcml6ZWRcIl0gPSA0NDAxXSA9IFwiVW5hdXRob3JpemVkXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkZvcmJpZGRlblwiXSA9IDQ0MDNdID0gXCJGb3JiaWRkZW5cIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiU3VicHJvdG9jb2xOb3RBY2NlcHRhYmxlXCJdID0gNDQwNl0gPSBcIlN1YnByb3RvY29sTm90QWNjZXB0YWJsZVwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJDb25uZWN0aW9uSW5pdGlhbGlzYXRpb25UaW1lb3V0XCJdID0gNDQwOF0gPSBcIkNvbm5lY3Rpb25Jbml0aWFsaXNhdGlvblRpbWVvdXRcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXRcIl0gPSA0NTA0XSA9IFwiQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXRcIjtcbiAgICAvKiogU3Vic2NyaWJlciBkaXN0aW5jdGlvbiBpcyB2ZXJ5IGltcG9ydGFudCAqL1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJTdWJzY3JpYmVyQWxyZWFkeUV4aXN0c1wiXSA9IDQ0MDldID0gXCJTdWJzY3JpYmVyQWxyZWFkeUV4aXN0c1wiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJUb29NYW55SW5pdGlhbGlzYXRpb25SZXF1ZXN0c1wiXSA9IDQ0MjldID0gXCJUb29NYW55SW5pdGlhbGlzYXRpb25SZXF1ZXN0c1wiO1xufSkoQ2xvc2VDb2RlIHx8IChDbG9zZUNvZGUgPSB7fSkpO1xuLyoqXG4gKiBUeXBlcyBvZiBtZXNzYWdlcyBhbGxvd2VkIHRvIGJlIHNlbnQgYnkgdGhlIGNsaWVudC9zZXJ2ZXIgb3ZlciB0aGUgV1MgcHJvdG9jb2wuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgdmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIE1lc3NhZ2VUeXBlW1wiQ29ubmVjdGlvbkluaXRcIl0gPSBcImNvbm5lY3Rpb25faW5pdFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiQ29ubmVjdGlvbkFja1wiXSA9IFwiY29ubmVjdGlvbl9hY2tcIjtcbiAgICBNZXNzYWdlVHlwZVtcIlBpbmdcIl0gPSBcInBpbmdcIjtcbiAgICBNZXNzYWdlVHlwZVtcIlBvbmdcIl0gPSBcInBvbmdcIjtcbiAgICBNZXNzYWdlVHlwZVtcIlN1YnNjcmliZVwiXSA9IFwic3Vic2NyaWJlXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJOZXh0XCJdID0gXCJuZXh0XCI7XG4gICAgTWVzc2FnZVR5cGVbXCJFcnJvclwiXSA9IFwiZXJyb3JcIjtcbiAgICBNZXNzYWdlVHlwZVtcIkNvbXBsZXRlXCJdID0gXCJjb21wbGV0ZVwiO1xufSkoTWVzc2FnZVR5cGUgfHwgKE1lc3NhZ2VUeXBlID0ge30pKTtcbi8qKlxuICogVmFsaWRhdGVzIHRoZSBtZXNzYWdlIGFnYWluc3QgdGhlIEdyYXBoUUwgb3ZlciBXZWJTb2NrZXQgUHJvdG9jb2wuXG4gKlxuICogSW52YWxpZCBtZXNzYWdlcyB3aWxsIHRocm93IGRlc2NyaXB0aXZlIGVycm9ycy5cbiAqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2UodmFsKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwpfWApO1xuICAgIH1cbiAgICBpZiAoIXZhbC50eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBpcyBtaXNzaW5nIHRoZSAndHlwZScgcHJvcGVydHlgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWwudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXNzYWdlIGlzIGV4cGVjdHMgdGhlICd0eXBlJyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC50eXBlKX1gKTtcbiAgICB9XG4gICAgc3dpdGNoICh2YWwudHlwZSkge1xuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbm5lY3Rpb25Jbml0OlxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbm5lY3Rpb25BY2s6XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUGluZzpcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Qb25nOiB7XG4gICAgICAgICAgICBpZiAodmFsLnBheWxvYWQgIT0gbnVsbCAmJiAhaXNPYmplY3QodmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gb2JqZWN0IG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCBcIiR7dmFsLnBheWxvYWR9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU3Vic2NyaWJlOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwuaWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNPYmplY3QodmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwucGF5bG9hZC5xdWVyeSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ3F1ZXJ5JyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLnF1ZXJ5KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwucGF5bG9hZC52YXJpYWJsZXMgIT0gbnVsbCAmJiAhaXNPYmplY3QodmFsLnBheWxvYWQudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcGF5bG9hZCBleHBlY3RzIHRoZSAndmFyaWFibGVzJyBwcm9wZXJ0eSB0byBiZSBhIGFuIG9iamVjdCBvciBudWxsaXNoIG9yIG1pc3NpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZC52YXJpYWJsZXMpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC5wYXlsb2FkLm9wZXJhdGlvbk5hbWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGV4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLm9wZXJhdGlvbk5hbWUpICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcGF5bG9hZCBleHBlY3RzIHRoZSAnb3BlcmF0aW9uTmFtZScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcgb3IgbnVsbGlzaCBvciBtaXNzaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQub3BlcmF0aW9uTmFtZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsLnBheWxvYWQuZXh0ZW5zaW9ucyAhPSBudWxsICYmICFpc09iamVjdCh2YWwucGF5bG9hZC5leHRlbnNpb25zKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcGF5bG9hZCBleHBlY3RzIHRoZSAnZXh0ZW5zaW9ucycgcHJvcGVydHkgdG8gYmUgYSBhbiBvYmplY3Qgb3IgbnVsbGlzaCBvciBtaXNzaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQuZXh0ZW5zaW9ucyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLk5leHQ6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ2lkJyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5pZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbC5pZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcmVxdWlyZXMgYSBub24tZW1wdHkgJ2lkJyBwcm9wZXJ0eWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc09iamVjdCh2YWwucGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdwYXlsb2FkJyBwcm9wZXJ0eSB0byBiZSBhbiBvYmplY3QsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkVycm9yOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwuaWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXJlR3JhcGhRTEVycm9ycyh2YWwucGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdwYXlsb2FkJyBwcm9wZXJ0eSB0byBiZSBhbiBhcnJheSBvZiBHcmFwaFFMIGVycm9ycywgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbC5wYXlsb2FkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQ29tcGxldGU6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ2lkJyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5pZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbC5pZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcmVxdWlyZXMgYSBub24tZW1wdHkgJ2lkJyBwcm9wZXJ0eWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXNzYWdlICd0eXBlJyBwcm9wZXJ0eSBcIiR7dmFsLnR5cGV9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIHZhbGlkIEdyYXBoUUwgb3ZlciBXZWJTb2NrZXQgbWVzc2FnZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHZhbGlkYXRlTWVzc2FnZWAgaW5zdGVhZC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc01lc3NhZ2UodmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFsaWRhdGVNZXNzYWdlKHZhbCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2VzIHRoZSByYXcgd2Vic29ja2V0IG1lc3NhZ2UgZGF0YSB0byBhIHZhbGlkIG1lc3NhZ2UuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNZXNzYWdlKGRhdGEsIHJldml2ZXIpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVNZXNzYWdlKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoZGF0YSwgcmV2aXZlcikgOiBkYXRhKTtcbn1cbi8qKlxuICogU3RyaW5naWZpZXMgYSB2YWxpZCBtZXNzYWdlIHJlYWR5IHRvIGJlIHNlbnQgdGhyb3VnaCB0aGUgc29ja2V0LlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeU1lc3NhZ2UobXNnLCByZXBsYWNlcikge1xuICAgIHZhbGlkYXRlTWVzc2FnZShtc2cpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtc2csIHJlcGxhY2VyKTtcbn1cbiJdLCJuYW1lcyI6WyJhcmVHcmFwaFFMRXJyb3JzIiwiZXh0ZW5kZWRUeXBlb2YiLCJpc09iamVjdCIsIkdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MIiwiREVQUkVDQVRFRF9HUkFQSFFMX1dTX1BST1RPQ09MIiwiQ2xvc2VDb2RlIiwiTWVzc2FnZVR5cGUiLCJ2YWxpZGF0ZU1lc3NhZ2UiLCJ2YWwiLCJFcnJvciIsInR5cGUiLCJDb25uZWN0aW9uSW5pdCIsIkNvbm5lY3Rpb25BY2siLCJQaW5nIiwiUG9uZyIsInBheWxvYWQiLCJTdWJzY3JpYmUiLCJpZCIsInF1ZXJ5IiwidmFyaWFibGVzIiwib3BlcmF0aW9uTmFtZSIsImV4dGVuc2lvbnMiLCJOZXh0IiwiSlNPTiIsInN0cmluZ2lmeSIsIkNvbXBsZXRlIiwiaXNNZXNzYWdlIiwiX2EiLCJwYXJzZU1lc3NhZ2UiLCJkYXRhIiwicmV2aXZlciIsInBhcnNlIiwic3RyaW5naWZ5TWVzc2FnZSIsIm1zZyIsInJlcGxhY2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphql-ws/lib/common.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphql-ws/lib/utils.mjs":
/*!***********************************************!*\
  !*** ./node_modules/graphql-ws/lib/utils.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areGraphQLErrors: () => (/* binding */ areGraphQLErrors),\n/* harmony export */   extendedTypeof: () => (/* binding */ extendedTypeof),\n/* harmony export */   isAsyncGenerator: () => (/* binding */ isAsyncGenerator),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   limitCloseReason: () => (/* binding */ limitCloseReason)\n/* harmony export */ });\n/** @private */ function extendedTypeof(val) {\n    if (val === null) {\n        return \"null\";\n    }\n    if (Array.isArray(val)) {\n        return \"array\";\n    }\n    return typeof val;\n}\n/** @private */ function isObject(val) {\n    return extendedTypeof(val) === \"object\";\n}\n/** @private */ function isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === \"function\";\n}\n/** @private */ function isAsyncGenerator(val) {\n    return isObject(val) && typeof Object(val)[Symbol.asyncIterator] === \"function\" && typeof val.return === \"function\";\n}\n/** @private */ function areGraphQLErrors(obj) {\n    return Array.isArray(obj) && // must be at least one error\n    obj.length > 0 && // error has at least a message\n    obj.every((ob)=>\"message\" in ob);\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */ function limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvdXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLGFBQWEsR0FDTixTQUFTQSxlQUFlQyxHQUFHO0lBQzlCLElBQUlBLFFBQVEsTUFBTTtRQUNkLE9BQU87SUFDWDtJQUNBLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsTUFBTTtRQUNwQixPQUFPO0lBQ1g7SUFDQSxPQUFPLE9BQU9BO0FBQ2xCO0FBQ0EsYUFBYSxHQUNOLFNBQVNHLFNBQVNILEdBQUc7SUFDeEIsT0FBT0QsZUFBZUMsU0FBUztBQUNuQztBQUNBLGFBQWEsR0FDTixTQUFTSSxnQkFBZ0JKLEdBQUc7SUFDL0IsT0FBTyxPQUFPSyxPQUFPTCxJQUFJLENBQUNNLE9BQU9DLGFBQWEsQ0FBQyxLQUFLO0FBQ3hEO0FBQ0EsYUFBYSxHQUNOLFNBQVNDLGlCQUFpQlIsR0FBRztJQUNoQyxPQUFRRyxTQUFTSCxRQUNiLE9BQU9LLE9BQU9MLElBQUksQ0FBQ00sT0FBT0MsYUFBYSxDQUFDLEtBQUssY0FDN0MsT0FBT1AsSUFBSVMsTUFBTSxLQUFLO0FBSzlCO0FBQ0EsYUFBYSxHQUNOLFNBQVNDLGlCQUFpQkMsR0FBRztJQUNoQyxPQUFRVixNQUFNQyxPQUFPLENBQUNTLFFBQ2xCLDZCQUE2QjtJQUM3QkEsSUFBSUMsTUFBTSxHQUFHLEtBQ2IsK0JBQStCO0lBQy9CRCxJQUFJRSxLQUFLLENBQUMsQ0FBQ0MsS0FBTyxhQUFhQTtBQUN2QztBQUNBOzs7OztDQUtDLEdBQ00sU0FBU0MsaUJBQWlCQyxNQUFNLEVBQUVDLFdBQVc7SUFDaEQsT0FBT0QsT0FBT0osTUFBTSxHQUFHLE1BQU1JLFNBQVNDO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52b2ljZS1hcHAtcHJvamVjdC1yb290Ly4vbm9kZV9tb2R1bGVzL2dyYXBocWwtd3MvbGliL3V0aWxzLm1qcz8zMzRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAcHJpdmF0ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZGVkVHlwZW9mKHZhbCkge1xuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWw7XG59XG4vKiogQHByaXZhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgICByZXR1cm4gZXh0ZW5kZWRUeXBlb2YodmFsKSA9PT0gJ29iamVjdCc7XG59XG4vKiogQHByaXZhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBPYmplY3QodmFsKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG4vKiogQHByaXZhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FzeW5jR2VuZXJhdG9yKHZhbCkge1xuICAgIHJldHVybiAoaXNPYmplY3QodmFsKSAmJlxuICAgICAgICB0eXBlb2YgT2JqZWN0KHZhbClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB2YWwucmV0dXJuID09PSAnZnVuY3Rpb24nXG4gICAgLy8gZm9yIGxhenkgb25lcywgd2Ugb25seSBuZWVkIHRoZSByZXR1cm4gYW55d2F5XG4gICAgLy8gdHlwZW9mIHZhbC50aHJvdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIC8vIHR5cGVvZiB2YWwubmV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICk7XG59XG4vKiogQHByaXZhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBhcmVHcmFwaFFMRXJyb3JzKG9iaikge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShvYmopICYmXG4gICAgICAgIC8vIG11c3QgYmUgYXQgbGVhc3Qgb25lIGVycm9yXG4gICAgICAgIG9iai5sZW5ndGggPiAwICYmXG4gICAgICAgIC8vIGVycm9yIGhhcyBhdCBsZWFzdCBhIG1lc3NhZ2VcbiAgICAgICAgb2JqLmV2ZXJ5KChvYikgPT4gJ21lc3NhZ2UnIGluIG9iKSk7XG59XG4vKipcbiAqIExpbWl0cyB0aGUgV2ViU29ja2V0IGNsb3NlIGV2ZW50IHJlYXNvbiB0byBub3QgZXhjZWVkIGEgbGVuZ3RoIG9mIG9uZSBmcmFtZS5cbiAqIFJlZmVyZW5jZTogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNS4yLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW1pdENsb3NlUmVhc29uKHJlYXNvbiwgd2hlblRvb0xvbmcpIHtcbiAgICByZXR1cm4gcmVhc29uLmxlbmd0aCA8IDEyNCA/IHJlYXNvbiA6IHdoZW5Ub29Mb25nO1xufVxuIl0sIm5hbWVzIjpbImV4dGVuZGVkVHlwZW9mIiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNPYmplY3QiLCJpc0FzeW5jSXRlcmFibGUiLCJPYmplY3QiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiaXNBc3luY0dlbmVyYXRvciIsInJldHVybiIsImFyZUdyYXBoUUxFcnJvcnMiLCJvYmoiLCJsZW5ndGgiLCJldmVyeSIsIm9iIiwibGltaXRDbG9zZVJlYXNvbiIsInJlYXNvbiIsIndoZW5Ub29Mb25nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphql-ws/lib/utils.mjs\n");

/***/ })

};
;